# 共享模型之管程

## Monitor

每个对象都有一个对象头，如果是32位的虚拟机，普通对象头占用64位，数组对象占用96位

普通对象头：

![image-20210302155631560](https://tva1.sinaimg.cn/large/e6c9d24ely1go5m77z1olj21ay09sjsb.jpg)

数组对象头：

![image-20210302155714691](https://tva1.sinaimg.cn/large/e6c9d24ely1go5m7yjlxgj21bg07owfz.jpg)

其中Mark word结构为：

![image-20210302155755483](https://tva1.sinaimg.cn/large/e6c9d24ely1go5m8nzvl7j21900kajwp.jpg)

Monitor被翻译为监视器或者管程。

每个java对象都可以关联一个Monitor对象（由操作系统提供），如果使用synchronized给对象上锁（重量级）之后，该对象头的Mark word中就被设置指向Monitor对象的指针。

![image-20210302204643453](https://tva1.sinaimg.cn/large/e6c9d24ely1go5ul8fs3uj20hb071gop.jpg)

* 刚开始Monitor中Owner为null
* 当Thread-2执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-2，Monitor中只能有一个Owner
* 在Thread-2上锁的过程中，如果Thread-3，Thread-4，Thread-5也来执行synchronized(obj)，就会进入EntryList BLOCKED
* Thread-2执行完同步代码块的内容，然后唤醒EntryList中等待的线程来竞争锁，竞争的时候是非公平的
* 图中WaitSet中的Thread-0，Thread-1是之前获得过锁，但条件不满足进入WAITING状态的线程，后面讲wait-notify时会分析

> 注意：
>
> * synchronized必须是进入同一个对象的monitor才能有上述效果
> * 不加synchronized的对象不会关联monitor，不遵从以上规则

## synchronized原理

你以为使用`synchronized(对象)`都会关联一个monitor对象吗？事实上这是一个重量级锁，jdk内部做了相应的优化。以下我们将介绍一些概念：轻量级锁、锁膨胀、自旋优化、锁重入、偏向锁

### 轻量级锁

轻量级锁的使用场景：如果一个对象虽然有多个线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁优化。

轻量级锁对使用者是透明的，即语法仍然是synchronized

```java
static final Object obj = new Object();
public static void method1(){
  synchronized(obj){
    //同步代码块A
    method2();
  }
}

public static void method2(){
  synchronized(obj){
    //同步代码块B
  }
}
```

* 创建锁记录（Lock Record）对象，每个线程的栈帧都会包含一个锁记录的结构，内部可以锁定对象的Mark word

![image-20210303004304339](https://tva1.sinaimg.cn/large/e6c9d24ely1go61f30qc7j20x20i4q8w.jpg)

* 让锁记录中Object reference指向锁对象，并尝试用cas替换Object的Mark word，将Mark word的值存入锁记录

![image-20210303004419970](https://tva1.sinaimg.cn/large/e6c9d24ely1go61gegbz3j20ye0joafb.jpg)

* 如果cas替换成功，对象头中存储了`锁记录地址和状态00`，表示由该线程对锁对象加锁，这时图示如下

![image-20210303004614821](https://tva1.sinaimg.cn/large/e6c9d24ely1go61idtmfcj20yi0jmwjj.jpg)

* 如果cas失败，有两种情况
  * 如果是其他线程已经持有了该Object的轻量级锁，这时表明有竞争，进入锁膨胀过程（升级为重量级锁）
  * 如果是自己执行了synchronized锁重入，那么再添加一条Lock Record作为重入的计数

![image-20210303004910672](https://tva1.sinaimg.cn/large/e6c9d24ely1go61lg5ge7j210c0mi0zu.jpg)



* 当退出synchronized代码块（解锁时），如果有取值为null的锁记录，表示有重入，这时重置锁记录，表示重入计数减一

![image-20210303005102699](https://tva1.sinaimg.cn/large/e6c9d24ely1go61ndlihgj20yg0jidkz.jpg)

* 当退出synchronized代码块（解锁时）锁记录的值不为null，这时使用cas将Mark word的值恢复给对象头
  * 成功，则解锁成功
  * 失败，说明轻量级锁进入了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程

### 锁膨胀

如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其他线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁

```java
static final Object obj = new Object();
public static void method1(){
  synchronized(obj){
    //同步代码块
  }
}
```

* 当Thread-1进行轻量级锁时，Thread-0已经对该对象加了轻量级锁

![image-20210303005658095](https://tva1.sinaimg.cn/large/e6c9d24ely1go61tjn6rjj218s0gadkh.jpg)

* 这时Thread-1加轻量级锁失败，进入锁膨胀流程
  * 即为Object对象申请Monitor锁，让Object指向重量级锁地址
  * 然后自己进入Monitor的EntryList BLOCKED

![image-20210303005902318](https://tva1.sinaimg.cn/large/e6c9d24ely1go61vpf91gj219a0g4jwb.jpg)



* 当Thread-0退出同步代码块解锁时，使用cas将Mark word的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中BLOCKED线程。

### 自旋优化

重量级锁竞争的时候，例如A线程占用了锁，此时B线程也来占用锁，B线程先不阻塞等待加入到EntryList中，而是自旋（for循环）若干次等待A线程释放锁

* 自旋会占用CPU时间，单核CPU自旋就是浪费，多核CPU自旋才能发挥优势
* 在java6之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就会少自旋甚至不自旋，总之，比较智能。
* java7之后不能控制是否开启自旋功能

### 偏向锁

轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行CAS操作。

java6引入偏向锁来进一步优化：只有第一次使用CAS将线程ID设置到对象的Mark word头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS。以后只要不发生竞争，这个对象就该线程所有。

![image-20210303012024561](https://tva1.sinaimg.cn/large/e6c9d24ely1go62hxetjhj21520gan0q.jpg)

一个对象创建时：

1. 如果开启了偏向锁（默认开启），那么对象创建后，mark word值为0x05即最后3位为101，这时它的thread，epoch，age都为0
2. 偏向锁默认是延迟的，不会再程序启动时立刻生效，如果想避免延迟，可以加VM参数-XX:BiasedLockingStartupDelay=0来禁用延迟
3. 如果没有开启偏向锁，那么对象创建后，markword值为0x01即最后3位为001，这时它的hashcode，age都为0，第一次用到hashcode才会赋值

## notify和wait

首先notify和wait必须要和synchronized搭配使用

`obj.wait()`：让进入到object监视器的线程到waitSet等待

`obj.notify()`：在object上正在waitSet等待的线程中挑一个唤醒

`obj.notifyAll()`：在object上正在waitSet等待的线程全部唤醒

她们都是线程之间进行协作的手段，都属于Object对象的方法。必须获得此对象的锁，才能调用这几个方法

> wait和sleep的区别？
>
> * wait必须要搭配synchronized使用，而sleep不需强制
> * wait方法会释放对象的锁，进入waitSet等待区，从而让其他线程有机会获取对象的锁。而sleep如果搭配synchronized使用，不会释放锁

### wait和notify原理

![image-20210303013547332](https://tva1.sinaimg.cn/large/e6c9d24ely1go62xy04mmj218o0icq8r.jpg)

* Owner线程发现不满足条件，调用wait方法，即可进入WaitSet变为WAITING状态
* BLOCKED和WAITING的线程都处于阻塞状态，不占用CPU时间片
* BLOCKED线程会在Owner线程释放时唤醒
* WAITING线程会在Owner线程调用notify或notifyAll时唤醒，但唤醒后并不意味着立刻获得锁，仍需进入EntryList重新竞争

### wait和notify的正确使用姿势

```java
synchronized(lock){
  while(条件不成立){
    lock.wait()
  }
  //干活
}

//另一个线程
synchronized(lock){
  lock.notifyAll();
}
```

## park和unpark

它们是LockSupport类中的方法，底层用的是Unsafe API

```java
//暂停当前线程
LockSupport.park()
  
//恢复某个线程的运行
LockSupport.park(暂停线程对象)
```

* 先park再unpark

```java
@Slf4j(topic = "c.packdemo")
public class PackDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()->{
            log.info("start...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("park...");
            LockSupport.park();
            log.info("resume...");
        }, "t1");
        t1.start();

        Thread.sleep(2000);
        log.info("unpark...");
        LockSupport.unpark(t1);
    }
}
```

输出

```
10:24:53 [t1] c.packdemo - start...
10:24:54 [t1] c.packdemo - park...
10:24:55 [main] c.packdemo - unpark...
10:24:55 [t1] c.packdemo - resume...
```

* 先unpark再park。把上面代码的sleep时间互调

输出

```
10:25:23 [t1] c.packdemo - start...
10:25:24 [main] c.packdemo - unpark...
10:25:25 [t1] c.packdemo - park...
10:25:25 [t1] c.packdemo - resume...
```

特点：

与wait和notify相比

1. wait和notify必须配合Object Monitor一起使用，而park，unpark不必
2. park和unpark是以线程为单位来阻塞和唤醒，而notify只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么精确
3. <u>park和unpark可以先unpark，而wait和notify不能先notify</u>

### park和unpark原理

每个线程都有一个Parker对象，由三部分组成`_counter`，`_cond`和`_mutex`

简单理解就是：park的时候会检查`_counter`，如果是0，就将自己放到`_cond`等待中；如果是1，就继续往下执行，并把`_cond`置为0；unpark(t)就是将线程t的`_counter`置为1并唤醒`_cond`的线程t，t线程恢复运行，设置`_counter`为0。

```java
public class PackDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()->{
            log.info("start...");  //step1
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("park...");  //step4
            LockSupport.park();  //step5 cond=1 -> cond=0
            log.info("resume...");  //step6
            LockSupport.park();  //step8
            log.info("over...");//step9
        }, "t1");
        t1.start();

        Thread.sleep(1000);
        log.info("unpark...");  //step2
        LockSupport.unpark(t1);  //step3 cond=1
        Thread.sleep(5000);
        LockSupport.unpark(t1);  //step7 cond=0 -> cond=1
        log.info("main over..."); ////step10
    }
}
```

## 线程状态

![image-20210303111109116](https://tva1.sinaimg.cn/large/e6c9d24ely1go6jklgwf0j215t0u0gux.jpg)

1. `NEW-&gt;RUNNABLE`

当调用`t.start()`方法时，由`NEW-&gt;RUNNABLE`

2. `RUNNABLE<->WAITING`

t线程用`synchronized(obj)`获取对象锁后

* 调用`obj.wait()`方法时，t线程从`RUNNABLE->WAITING`
* 调用`obj.notify()`，`obj.notifyAll()`，`t.interrupt()`时
  * 竞争锁成功，t线程从`WAITING->RUNNABLE`
  * 竞争锁失败，t线程从`WAITING->BLOCKED`

3. `RUNNABLE<->WAITING`

* 当前线程调用`t.join()`方法时，当前线程从`RUNNABLE->WAITING`
  * 主要是当前线程在t线程对象的Monitor上等待
* t线程运行结束，或调用当前线程的interrupt时，当前线程从`WAITING->RUNNABLE`

4. `RUNNABLE<->WAITING`

* 当前线程调用`LockSupport.park()`方法会让当前线程从`RUNNABLE->WAITING`
* 调用`LockSupport.unpark(目标线程)`或调用了线程的interrupt()，会让目标线程从`WAITING->RUNNABLE`

5. `RUNNABLE<->TIMED_WAITING`

同2，`wait(long n)`

6. RUNNABLE<->TIMED_WAITING

同3，`join(long n)`

7. `RUNNABLE<->TIMED_WAITING`

* 当前线程调用`Thread.sleep(long n)`，当前线程从`RUNNABLE->TIMED_WAITING`
* 当前线程等待超过了n毫秒，当前线程从`TIMED_WAITING->RUNNABLE`

8. `RUNNABLE<->TIMED_WAITING`

同4，`LockSupport.parkNanos(long nanos)`

9. `RUNNABLE<->BLOCKED`

* t线程用`synchronized(obj)`获取了对象锁时如果竞争失败，从`RUNNABLE->BLOCKED`
* 持obj锁线程的同步代码块执行完毕，会唤醒该线程对象所有BLOCKED的线程重新竞争，如果其中t线程竞争成功，从`BLOCKED->RUNNABLE`，其他失败的线程仍然BLOCKED

10. `RUNNABLE->TERMINATED`

线程运行结束

## 死锁



## 哲学家问题



## RerentrantLock 

