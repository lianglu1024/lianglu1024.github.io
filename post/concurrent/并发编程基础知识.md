# 并发编程基础知识

同步和异步：同步指的是A任务（代码）执行完成之后才能执行B任务（代码），一种顺序性执行。异步指的是无需等到A执行完成才去执行B，**Java中一般采用多线程的方式完成异步**

并行和并发：并行需要借助多核，同一时刻多个进程在运行。并发只的是一段时间内多个线程在运行

## 创建多线程方式

1. 直接使用Thread

```java
package com.zstu.concurrent.demo;

import lombok.extern.slf4j.Slf4j;

@Slf4j(topic = "c.demo01")
public class Demo01 {
    public static void main(String[] args) {
        //创建线程对象，t1是线程的名字
        Thread t = new Thread("t1"){
            //run 方法是要执行的任务
            @Override
            public void run() {
                log.info("{} running", Thread.currentThread().getName());
            }
        };
        //启动线程
        t.start();

        log.info("{} running", Thread.currentThread().getName());
    }
}
```

执行结果

```
13:33:14 [main] c.demo01 - main running
13:33:14 [t1] c.demo01 - t1 running
```

2. Runnable配合Thread

把线程和任务分开，推荐使用这种方式

```java
@Slf4j(topic = "c.demo02")
public class Demo02 {
    public static void main(String[] args) {
        Runnable r = new Runnable() {
            @Override
            public void run() {
                log.info("{} running", Thread.currentThread().getName());
            }
        };
        Thread t = new Thread(r, "t1");
        t.start();
        log.info("{} running", Thread.currentThread().getName());
    }
}
```

jdk8之后可以使用lambda表达式的方式创建线程

```java
@Slf4j(topic = "c.demo02")
public class Demo02 {
    public static void main(String[] args) {
        Runnable r = ()->log.info("{} running", Thread.currentThread().getName());
        Thread t = new Thread(r, "t1");
        t.start();
        log.info("{} running", Thread.currentThread().getName());
    }
}
```

3. FutureTask配合Thread使用

FutureTask的特点就是可以拿到子线程运行的结果

```java
@Slf4j(topic = "c.demo03")
public class Demo03 {
    public static void main(String[] args) throws Exception{
        //泛型是代表要返回的结果类型
        //FutureTask构造方法里也可以放Runnable类型，但是Runnable接口是没有返回值
        FutureTask<Integer> task = new FutureTask<>(new Callable<Integer>(){
            @Override
            public Integer call() throws Exception {
                log.info("{} running", Thread.currentThread().getName());
                return 10;
            }
        });

        new Thread(task, "t").start();
        //注意，如果线程t没有执行完成是没有返回结果，该方法会阻塞主线程
        Integer result = task.get();
        log.info("结果是：{}", result);
    }
}
```

运行结果：

```
13:43:44 [t] c.demo03 - t running
13:43:44 [main] c.demo03 - 结果是：10
```

## 常见操作

| 方法名           | static | 功能说明                                      | 注意                                                         |
| ---------------- | ------ | --------------------------------------------- | ------------------------------------------------------------ |
| start()          |        | 启动一个新线程，在新的线程运行run方法中的代码 | start方法只是让线程进入就绪，里面代码不一定立刻运行（CPU的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出现illegalThreadStateException |
| run()            |        | 新线程启动后会调用的方法                      | 如果在构造Thread对象是传递了Runnable参数，则线程启动后会调用Runnable中的run方法，否则默认不执行任何操作。但可以创建Thread的子类对象，来覆盖默认行为 |
| join()           |        | 等待线程运行结束                              |                                                              |
| join(long n)     |        | 等待线程运行结束，最多等待n毫秒               |                                                              |
| getId()          |        | 获取线程长整型的id                            | id是唯一的                                                   |
| getName()        |        | 获取线程名                                    |                                                              |
| setName(String)  |        | 修改线程名                                    |                                                              |
| getPriority()    |        | 获取线程优先级                                |                                                              |
| setPriority(int) |        | 修改线程优先级                                | java中规定线程优先级是1~10的整数，较大的优先级能提高该线程被CPU调度的机率 |
| getState()       |        | 获取线程状态                                  | java中线程状态是6个enum表示，分别为：NEW,RUNNABLR,BLOCK,WAITING,TIMED_WAITING,TERMINATED |
| isInterrupted()  |        | 判断是否被打断                                | 不会清楚`打断标记`                                          |
| isAlive()        |        | 线程是否存活（还没运行完毕）                  |                                                              |
| interrupt()      |        | 打断线程                                      | 如果被打断线程正在sleep,wait,join会导致被打断的线程抛出InterruptedException，并清楚`打断标记`；如果打断的正在运行的线程，则会设置`打断标记`；park的线程会被打断，也会设置`打断标记` |
| interrupted() | static | 判断当前线程是否被打断 | 会清除`打断标记` |
| currentThread    | static | 获取当前正在执行的线程                        |                                                              |
| sleep(long n) | static | 让当前执行的线程休眠n毫秒，休眠时让出cpu的时间片给其他线程 | 1.调用sleep会让当前线程从Running进入Timed Waiting状态（阻塞）2。其他线程可以使用Interrupt方法打断正在睡眠的线程，这时sleep方法会抛出`InterruptedException` |
| yield() | static | 提示线程调度器让出当前线程对CPU的使用 | 1.调用yield会让当前线程从Running进入Runnable就绪状态，然后调度执行其他线程2.具体的实现依赖于操作系统的任务调度器 |

### join方法

`线程t.join()`：在<u>当前线程中加入了线程t的执行，当前线程阻塞，异步变同步</u>

`线程t.join(n)`：如果t线程m（m<n）毫秒执行完成，那么就阻塞m毫秒，否则阻塞n毫秒

```java
@Slf4j(topic = "c.demo04")
public class Demo04 {
    public static void main (String[] args) throws InterruptedException {
        Thread t1 = new Thread(()->{
            log.info("子线程开始");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("子线程结束");
        });
        t1.start();
        t1.join(); //不会往下执行，知道t1执行完成
        log.info("结束");
    }
}
```

### 守护线程

默认情况下，java进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其他非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。<u>写在哪个线程里就是守护着哪个线程</u>。

```java
@Slf4j(topic = "c.daemondemo")
public class DaemonDemo {
    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
            log.info("子线程开始");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("子线程结束");
        });
        t1.setDaemon(true);
        t1.start();
        log.info("结束");  //主线程结束后，守护线程就也结束了
    }
}
```

输出

```
11:56:26 [Thread-0] c.daemondemo - 子线程开始
11:56:26 [main] c.daemondemo - 结束
```



