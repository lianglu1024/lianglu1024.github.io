# 隔离性和MVCC

当数据库上有多个事务同时执行的时候，就可能出现脏读、不可重复读、幻读的问题

* 脏读：事务T1读取了事务T2未提交的数据（这个数据可能会被T2回滚掉）
* 不可重复读：事务T1在本事务里读取同一条记录出现了不同值
* 幻读：一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来

为了解决这些问题，就有了“隔离级别”的概念。

在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释：

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。**当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的**。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

查看当前数据库的隔离级别

```
mysql> show variables like 'transaction_isolation';
Variable_name	Value
transaction_isolation	READ-COMMITTED
```

我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。

我们不想读到其他事务修改的值

READ COMMITTED和REPEATABLE READ隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同 