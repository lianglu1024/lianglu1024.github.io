# 乐观锁

乐观锁是相对于synchronized来说的，使用synchronized给对象加的是重量级锁，线程上下文切换代价比较大，使用CAS机制可以避免加锁。

我们先看一个取钱的并发问题

```java
public class Demo {

    public static int balance=200000;

    public static void main(String[] args) throws InterruptedException {
        List<Thread> list = new ArrayList<>();
        for(int i=0;i<10000;i++){
            list.add( new Thread(()->{
                withdraw(10);
            }));
        }

        list.forEach(item->item.start());
        list.forEach(item-> {
            try {
                item.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        System.out.println(balance);
    }

    /**
     * 取钱
     * @param amount
     */
    public static void withdraw(int amount) {
        balance -= amount;
    }
}
```

当10000个线程同时对balance去操作的时候，结果就发生了错误。如何使用乐观锁解决问题呢？

```java
public class CASDemo {

    public static AtomicInteger balance=new AtomicInteger(200000);

    public static void main(String[] args) throws InterruptedException {
        List<Thread> list = new ArrayList<>();
        for(int i=0;i<10000;i++){
            list.add( new Thread(()->{
                withdraw(10);
            }));
        }

        list.forEach(item->item.start());
        list.forEach(item-> {
            try {
                item.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        System.out.println(balance);
    }

    public static void withdraw(int amount) {
        while(true){
            int expect = balance.get();
            int update = expect - amount;

            if(balance.compareAndSet(expect, update)){
                break;
            }
        }
    }
}
```

## CAS

CAS：compare and swap，cas操作是系统保证的原子性

```java
//需要不断尝试，直到成功 
while(true){
     int expect = balance.get();
     int update = expect - amount;
		//如果此刻expect的值还是等于balance.get()，那么我们就将balance的值设为update
    //如果其他线程修改了balance的值，这个if条件就不成立，进入循环反复验证
     if(balance.compareAndSet(expect, update)){
         break;
   }
}
```

> 注意：
>
> 其实CAS的底层是lock cmpxchg指令（X86架构），在单核和多核cpu下都能保证【比较-交换】原子性
>
> 在多核状态下，某个核执行到lock指令，cpu会让总线锁住，当这个核把指令执行完成之后，再开启总线。这个过程不会被线程的调度机制所打断，保证了多个线程对内存的操作是准确的，原子的

<u>CAS必须借助volatile才能读取到共享变量的最新值来实现比较并交换的效果</u>。我们可以看一下AtomInteger内部

```java
public class AtomicInteger extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 6214790243416807050L;

    // setup to use Unsafe.compareAndSwapInt for updates
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset;

    static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }

    //volatile保证变量的可见性
    private volatile int value;
```



