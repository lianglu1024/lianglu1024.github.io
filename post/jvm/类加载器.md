# 类加载器

类加载器的作用就是加载class文件到虚拟机中，根据加载不同目录下的class文件，我们分为了三种类加载器以及自定义类加载器。<u>也就是说，不同的类加载器会去对应的目录中去加载类</u>。注意，每一个对象都会对应自己的类加载器。

| 名称                    | 加载哪里的类          | 说明                             |
| ----------------------- | --------------------- | -------------------------------- |
| Bootstrap ClassLoader   | JAVA_HOME/jre/lib     | C++编写，无法直接访问，由JVM启动 |
| Extension ClassLoader   | JAVA_HOME/jre/lib/ext | 上级为Bootstrap                  |
| Application ClassLoader | classpath             | 上级为Extension                  |
| 自定义类加载器          | 自定义                | 上级为Application                |

```java
public class ClassLoaderDemo {
	public static void main(String[] args) {
		// 启动类加载器
		System.out.println(Object.class.getClassLoader()); // null
		// ZipFileStore放在ext目录的jar包下，扩展类加载器
		System.out.println(ZipFileStore.class.getClassLoader());  //sun.misc.Launcher$ExtClassLoader@3cd1a2f1
		// 应用类加载器
		System.out.println(ClassLoaderDemo.class.getClassLoader());  //sun.misc.Launcher$AppClassLoader@18b4aac2
	}
}
```

## 双亲委派机制

```java
public class ClassLoaderDemo {
	public static void main(String[] args) throws ClassNotFoundException {
		Class<?> aClass = ClassLoaderDemo.class.getClassLoader().loadClass("com.alibaba.dubbo.container.spring.SpringContainer");
		System.out.println(aClass.getClassLoader());
	}
}
```

当我们加载SpringContainer这个类的时候，首先看AppClassLoader有没有加载过，如果已经加载，直接返回；如果没有加载，询问上级ExtClassLoader有没有加载过，如果加载过直接返回；如果没有加载，询问上级Bootstrap类加载器有没有加载过，如果加载过直接返回，如果没有加载告诉ExtClassLoader，ExtClassLoader再告诉AppClassLoader，这时AppClassLoader从classpath路径下去加载SpringContainer。

![image-20210310183430477](https://tva1.sinaimg.cn/large/008eGmZEly1goezq1n1v8j30bz08xaag.jpg)

双亲委派的代码

```java
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // 首先判断这个类有没有被加载
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    // 有上级的话，委派上级loadClass
                    c = parent.loadClass(name, false);
                } else {
                    // parent为null，说明是Bootstrap类加载器
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
            }

            if (c == null) {
                long t1 = System.nanoTime();
                //每一层找不到，调用findCLass方法(自定义类加载器)来加载
                c = findClass(name);

                // this is the defining class loader; record the stats
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

## 如何打破双亲委派

如果我们定义的类与JAVA_HOME/jre包下的类重名，由于双亲委派的缘故，我们始终无法加载到自己的类，这时候我们就需要打破双亲委派机制。

<u>简而言之，打破双亲委派机制就是自定义类加载器，重写loadClass方法，优先加载自己的类</u>。

打破双亲委派的例子：

* Tomcat中的web 容器类加载器也是破坏了双亲委托模式的，自定义的WebApplicationClassLoader除了核心类库外，都是优先加载自己路径下的Class；
* 使用SPI server provider模式的JDBC JAXP都是破坏了双亲委托模式的，在核心类库rt.jar的加载过程中需要加载第三方厂商的类，直接指定使用线程上下文类加载器也就是应用程序类加载器来加载这些类

## 自定义类加载器

1、如果不想打破双亲委派机制，那么只需要重写findClass方法即可

2、如果想打破双亲委派机制，那么就重写整个loadClass方法

以不想打破双亲委派机制为例

```java
public class LoadDemo {
    public static void main(String[] args) throws Exception {
        MyClassLoader classLoader = new MyClassLoader();
        Class<?> c1 = classLoader.loadClass("MapImpl1");
        Class<?> c2 = classLoader.loadClass("MapImpl1");
        System.out.println(c1 == c2);

        MyClassLoader classLoader2 = new MyClassLoader();
        Class<?> c3 = classLoader2.loadClass("MapImpl1");
        System.out.println(c1 == c3);

        c1.newInstance();
    }
}

class MyClassLoader extends ClassLoader {

    @Override // name 就是类名称
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        String path = "e:\\myclasspath\\" + name + ".class";

        try {
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            Files.copy(Paths.get(path), os);

            // 得到字节数组
            byte[] bytes = os.toByteArray();

            // byte[] -> *.class
            return defineClass(name, bytes, 0, bytes.length);

        } catch (IOException e) {
            e.printStackTrace();
            throw new ClassNotFoundException("类文件未找到", e);
        }
    }
}
```







