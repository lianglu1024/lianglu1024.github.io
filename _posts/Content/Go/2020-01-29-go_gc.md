---

layout: post
title: go gc
category: 技术
tags: Go
keywords: Go gc

---

## 前言

* TOC
{:toc}

[Garbage Collection In Go : Part I - Semantics](https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html)
[Garbage Collection In Go : Part II - GC Traces](https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html)
[Garbage Collection In Go : Part III - GC Pacing](https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html)

[万字长文深入浅出 Golang Runtime](https://zhuanlan.zhihu.com/p/95056679)

现代计算机语言大多数都带有自动内存管理功能，也就是垃圾收集（GC）。程序可以使用堆中的内存，但我们没必要手工去释放。垃圾收集器可以知道哪些内存是垃圾，然后归还给操作系统。垃圾收集包括标记-清除、停止-拷贝两大类算法，停止-拷贝算法被认为是最快的垃圾收集算法，但停止-拷贝算法有缺陷STW（Stop-The-World）。 **在自动内存管理领域的一个研究的重点，就是如何缩短这种停顿时间**。以 Go 语言为例，它的停顿时间从早期的几十毫秒，已经降低到了几毫秒。甚至有一些激进的算法，力图实现不用停顿。增量收集和并发收集算法，就是在这方面的有益探索。

增量收集可以每次只回收部分对象，没必要一次把活干完，从而减少停顿。并发收集就是在不影响程序执行的情况下，并发地执行垃圾收集工作。为了讨论增量和并发收集算法，我们定义两个角色：一个是收集器（Collector），负责垃圾收集；一个是变异器/应用程序（Mutator），它会造成可达对象的改变。

[Visualizing memory management in Golang](https://deepu.tech/memory-management-in-golang/#:~:text=collection%20comes%20in.-,Go%20Memory%20management,is%20well%20optimized%20and%20efficient.) 有动图建议细读

Go 的 GC 有且只会有一个参数进行调优，也就是我们所说的 GOGC，目的是为了防止大家在一大堆调优参数中摸不着头脑。 默认值是 100。这个 100 表示当内存的增加值小于等于 100% 时会强制进行一次垃圾回收。我们可以通过环境变量将这个值修改成 200，表示当内存增加 200% 时强制进行垃圾回收。或者将这个值设置为负数表示不进行垃圾回收。

## 三色标记法

[V8 增量 GC 之三色标记](https://malcolmyu.github.io/2019/07/07/Tri-Color-Marking/)三色标记主要是为了解决增量标记中传统双色标记过程无法分片的问题，有了三色标记，传统的双色标记便可以暂停重启，因此就可以划分成小段，变成跟 mutator 并发的方式来运行；写屏障则是用来解决并发中 mutator 变化，导致有用内存被清理的问题。

### 为什么双色标记就不行

采取 STW 这样凶残的策略，主要还是防止 mutator 在 GC 的时候捣乱——这跟你用扫地机器人的时候先把狗（Mutator/Application）先锁起来，等房子全部打扫完再把狗放开 的道理是一样的（Stop The Dog）。

[新一代垃圾回收器ZGC的探索与实践](https://mp.weixin.qq.com/s/ag5u2EPObx7bZr7hkcrOTg) **与jvm ZGC 非常类似**。自己的理解：
1. java对象头信息是跟对象自身定义的数据结构无关的，**这些信息所记录的状态是用于JVM对对象的管理的**（比如并发访问和gc）。
2. gc root 是一些固定特点的对象，一直存在。gc过程可以看做给 gc root加子节点的过程，最后得出一棵树（可达对象在“物理平面”是犬牙交错的），节点有两种状态：在不在树上（可达不可达，对象头mark word 有专门字段），在树上的节点不会被回收。事实上树并不存在（否则对象头 就得有字段表示子节点了），只是gc 线程遍历轨迹的一种表示。
3. 抛开gc 线程和应用线程，线程A和线程B竞争访问同一个对象，可以线程安全的一个底层机制就是，对象头 里有一个mark word 标记了对象是线程A的“人”，当线程B 从对象 mark word 中发现 对象“名花有主”了，就会放弃操作 对象，等待。
4. gc 线程和 应用线程 也是如此，之前 gc 和 应用线程没有 沟通机制，所以gc 干活儿的时候，应用线程就得 “歇着”。涂色 本质上 是提供了一种沟通渠道，在对象上做标记（就像对象mark word上的 线程标识符一样），gc 线程便不会回收这些对象了。

小时候看动画片《一休》，提到有一次一休的师兄被惩罚去树林里数一下树有多少，结果下雨天摔倒啥的，很容易就忘了刚才数到哪了。后来一休想了个办法，拿来一捆绳子，每棵树上系一根绳子，数一下剩下多少根绳子，就知道有多少棵树了。 

[Go 垃圾回收（三）——三色标记法是什么鬼？](https://zhuanlan.zhihu.com/p/105495961/)

因为增量回收是并发的（concurrent），这就意味着 GC 可能被随时暂停、重启，因此暂停时需要保存当时的扫描结果，等下一波 GC 来之后还能继续启动。而双色标记实际上仅仅是对扫描结果的描述：非黑即白，但忽略了对扫描进行状态的描述：这个点的子节点扫完了没有？假如我上次停在这样一个图上，重新启动的时候我就不仅要问：到底 A、B 点要不要扫子节点？

![](/public/upload/go/black_white.jpg)

相比传统的标记清扫算法，**三色标记最大的好处是可以异步执行**，从而可以以中断时间极少的代价或者完全没有中断来进行整个 GC。三色标记法很简单。
1. 最开始所有对象都是白色的，之后把其中**全局变量和函数栈里的对象**置为灰色。
2. 把灰色的对象全部置为黑色，然后把原先灰色对象指向的变量都置为灰色，以此类推。
3. 等发现没有对象可以被置为灰色时(非黑即白)，所有的白色变量就一定是需要被清理的垃圾了。

![](/public/upload/go/three_color_marking.gif)

[Go: How Does the Garbage Collector Mark the Memory?](https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976)GC 从栈开始，递归地顺着指针找指针指向的对象，遍历内存。每个指针被加入到一个 work pool(`type workbuf struct`) 中的队列。后台运行的标记 worker 从这个 work pool 中拿到前面出列的 指针，扫描这个对象然后把在这个对象里找到的指针加入到队列。归功于每一个 span 中的名为 gcmarkBits 的 bitmap 属性，三色被原生地实现了，bitmap 对 scan 中相应的 bit 设为 1 来追踪 对象。黑色和灰色表示的意义相同。处理的不同之处在于
1. 标记为灰色时是找到对象对应的bitmap，标记，加入到扫描队列，
2. 标黑就是标记，所以当灰色对象从队列中取出后，我们就可以认为这个对象是黑色对象了

PS：感觉三色标记比较重要的 是这个work pool， 每次gc 协程恢复执行后，可以从work pool 拿到对象继续工作。

### 调皮的 mutator

什么是失败的垃圾回收？无非就是两点：
1. 把有用的东西扔了；
2. 把没用的东西留着；这个可以下一轮再说

[Go 垃圾回收（四）——一次完整的回收](https://zhuanlan.zhihu.com/p/105571503)

三色**标记**法是一种可以并发执行的算法。标记期间，mutator很有可能将已经标记为扫描完事儿的节点（黑色节点）续上一个当时还未被扫描的白色节点。那么这些对象该怎么通知到 GC，怎么给他们着色呢？这个时候就需要我们的 Write Barrier 出马了。Write Barrier 主要做这样一件事情，**修改原先的写逻辑，当白色节点交由黑色节点引用时， 立刻对被引用节点进行着色，并且着色为”灰色“**。因此打开了 Write Barrier 可以保证了三色标记法在并发下安全正确地运行。 另一种表述：since the garbage collector can run concurrently with our Go program, it needs a way to detect potential changes in the memory while scanning. To tackle that potential issue, an algorithm of write barrier is implemented and will allow Go to track any pointer changes. The garbage finally stops the world, flushes the changes made on each write barrier to the work pool and performs the remaining marking. PS：  Write Barrier 可以追踪标记期间变化的 对象并将它们加入到work pool

[Go GC visualized](https://speakerdeck.com/deepu105/go-gc-visualized) 图解

## 整体实现

[深入理解Go-垃圾回收机制](https://www.mdeditor.tw/pl/2h5z) 分析的非常好

[Golang源码探索(三) GC的实现原理](https://www.cnblogs.com/zkweb/p/7880099.html)GO的GC是并行GC, 也就是GC的大部分处理和普通的go代码是同时运行的, 这让GO的GC流程比较复杂.

首先GC有四个阶段, 它们分别是:

1. Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC
2. Mark: 扫描所有根对象, 和根对象可以到达的所有对象, 标记它们不被回收
3. Mark Termination: 完成标记工作, 重新扫描部分根对象(要求STW)
4. Sweep: 按标记结果清扫span

在GC过程中会有两种后台任务(G), 一种是标记用的后台任务, 一种是清扫用的后台任务.
1. 标记用的后台任务会在需要时启动, 可以同时工作的后台任务数量大约是P的数量的25%, 也就是go所讲的让25%的cpu用在GC上的根据.
2. 清扫用的后台任务在程序启动时会启动一个, 进入清扫阶段时唤醒.

## 源码入口

`$GOROOT/src/runtime/mgc.go` go触发gc会从gcStart函数开始

## GC友好的代码
避免内存分配和赋值
1. 尽量使用引用传递
2. 初始化至合适的大小
3. 复用内存