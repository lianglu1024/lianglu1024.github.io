# 共享模型之管程

## Monitor

每个对象都有一个对象头，如果是32位的虚拟机，普通对象头占用64位，数组对象占用96位

普通对象头：

![image-20210302155631560](https://tva1.sinaimg.cn/large/e6c9d24ely1go5m77z1olj21ay09sjsb.jpg)

数组对象头：

![image-20210302155714691](https://tva1.sinaimg.cn/large/e6c9d24ely1go5m7yjlxgj21bg07owfz.jpg)

其中Mark word结构为：

![image-20210302155755483](https://tva1.sinaimg.cn/large/e6c9d24ely1go5m8nzvl7j21900kajwp.jpg)

Monitor被翻译为监视器或者管程。

每个java对象都可以关联一个Monitor对象（由操作系统提供），如果使用synchronized给对象上锁（重量级）之后，该对象头的Mark word中就被设置指向Monitor对象的指针。

![image-20210302204643453](https://tva1.sinaimg.cn/large/e6c9d24ely1go5ul8fs3uj20hb071gop.jpg)

* 刚开始Monitor中Owner为null
* 当Thread-2执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-2，Monitor中只能有一个Owner
* 在Thread-2上锁的过程中，如果Thread-3，Thread-4，Thread-5也来执行synchronized(obj)，就会进入EntryList BLOCKED
* Thread-2执行完同步代码块的内容，然后唤醒EntryList中等待的线程来竞争锁，竞争的时候是非公平的
* 图中WaitSet中的Thread-0，Thread-1是之前获得过锁，但条件不满足进入WAITING状态的线程，后面讲wait-notify时会分析

> 注意：
>
> * synchronized必须是进入同一个对象的monitor才能有上述效果
> * 不加synchronized的对象不会关联monitor，不遵从以上规则

## synchronized原理

你以为使用`synchronized(对象)`都会关联一个monitor对象吗？事实上这是一个重量级锁，jdk内部做了相应的优化。以下我们将介绍一些概念：轻量级锁、锁膨胀、自旋优化、锁重入、偏向锁

### 轻量级锁

轻量级锁的使用场景：如果一个对象虽然有多个线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁优化。

轻量级锁对使用者是透明的，即语法仍然是synchronized

```java
static final Object obj = new Object();
public static void method1(){
  synchronized(obj){
    //同步代码块A
    method2();
  }
}

public static void method2(){
  synchronized(obj){
    //同步代码块B
  }
}
```

* 创建锁记录（Lock Record）对象，每个线程的栈帧都会包含一个锁记录的结构，内部可以锁定对象的Mark word

![image-20210303004304339](https://tva1.sinaimg.cn/large/e6c9d24ely1go61f30qc7j20x20i4q8w.jpg)

* 让锁记录中Object reference指向锁对象，并尝试用cas替换Object的Mark word，将Mark word的值存入锁记录

![image-20210303004419970](https://tva1.sinaimg.cn/large/e6c9d24ely1go61gegbz3j20ye0joafb.jpg)

* 如果cas替换成功，对象头中存储了`锁记录地址和状态00`，表示由该线程对锁对象加锁，这时图示如下

![image-20210303004614821](https://tva1.sinaimg.cn/large/e6c9d24ely1go61idtmfcj20yi0jmwjj.jpg)

* 如果cas失败，有两种情况
  * 如果是其他线程已经持有了该Object的轻量级锁，这时表明有竞争，进入锁膨胀过程（升级为重量级锁）
  * 如果是自己执行了synchronized锁重入，那么再添加一条Lock Record作为重入的计数

![image-20210303004910672](https://tva1.sinaimg.cn/large/e6c9d24ely1go61lg5ge7j210c0mi0zu.jpg)



* 当退出synchronized代码块（解锁时），如果有取值为null的锁记录，表示有重入，这时重置锁记录，表示重入计数减一

![image-20210303005102699](https://tva1.sinaimg.cn/large/e6c9d24ely1go61ndlihgj20yg0jidkz.jpg)

* 当退出synchronized代码块（解锁时）锁记录的值不为null，这时使用cas将Mark word的值恢复给对象头
  * 成功，则解锁成功
  * 失败，说明轻量级锁进入了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程

### 锁膨胀

如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其他线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁

```java
static final Object obj = new Object();
public static void method1(){
  synchronized(obj){
    //同步代码块
  }
}
```

* 当Thread-1进行轻量级锁时，Thread-0已经对该对象加了轻量级锁

![image-20210303005658095](https://tva1.sinaimg.cn/large/e6c9d24ely1go61tjn6rjj218s0gadkh.jpg)

* 这时Thread-1加轻量级锁失败，进入锁膨胀流程
  * 即为Object对象申请Monitor锁，让Object指向重量级锁地址
  * 然后自己进入Monitor的EntryList BLOCKED

![image-20210303005902318](https://tva1.sinaimg.cn/large/e6c9d24ely1go61vpf91gj219a0g4jwb.jpg)



* 当Thread-0退出同步代码块解锁时，使用cas将Mark word的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中BLOCKED线程。

### 自旋优化

重量级锁竞争的时候，例如A线程占用了锁，此时B线程也来占用锁，B线程先不阻塞等待加入到EntryList中，而是自旋（for循环）若干次等待A线程释放锁

* 自旋会占用CPU时间，单核CPU自旋就是浪费，多核CPU自旋才能发挥优势
* 在java6之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就会少自旋甚至不自旋，总之，比较智能。
* java7之后不能控制是否开启自旋功能

### 偏向锁

轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行CAS操作。

java6引入偏向锁来进一步优化：只有第一次使用CAS将线程ID设置到对象的Mark word头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS。以后只要不发生竞争，这个对象就该线程所有。

![image-20210303012024561](https://tva1.sinaimg.cn/large/e6c9d24ely1go62hxetjhj21520gan0q.jpg)

一个对象创建时：

1. 如果开启了偏向锁（默认开启），那么对象创建后，mark word值为0x05即最后3位为101，这时它的thread，epoch，age都为0
2. 偏向锁默认是延迟的，不会再程序启动时立刻生效，如果想避免延迟，可以加VM参数-XX:BiasedLockingStartupDelay=0来禁用延迟
3. 如果没有开启偏向锁，那么对象创建后，markword值为0x01即最后3位为001，这时它的hashcode，age都为0，第一次用到hashcode才会赋值

## notify和wait

首先notify和wait必须要和synchronized搭配使用

`obj.wait()`：让进入到object监视器的线程到waitSet等待

`obj.notify()`：在object上正在waitSet等待的线程中挑一个唤醒

`obj.notifyAll()`：在object上正在waitSet等待的线程全部唤醒

她们都是线程之间进行协作的手段，都属于Object对象的方法。必须获得此对象的锁，才能调用这几个方法

> wait和sleep的区别？
>
> * wait必须要搭配synchronized使用，而sleep不需强制
> * wait方法会释放对象的锁，进入waitSet等待区，从而让其他线程有机会获取对象的锁。而sleep如果搭配synchronized使用，不会释放锁

#### wait和notify原理

![image-20210303013547332](https://tva1.sinaimg.cn/large/e6c9d24ely1go62xy04mmj218o0icq8r.jpg)

* Owner线程发现不满足条件，调用wait方法，即可进入WaitSet变为WAITING状态
* BLOCKED和WAITING的线程都处于阻塞状态，不占用CPU时间片
* BLOCKED线程会在Owner线程释放时唤醒
* WAITING线程会在Owner线程调用notify或notifyAll时唤醒，但唤醒后并不意味着立刻获得锁，仍需进入EntryList重新竞争

wait和notify的正确使用姿势

```java
synchronized(lock){
  while(条件不成立){
    lock.wait()
  }
  //干活
}

//另一个线程
synchronized(lock){
  lock.notifyAll();
}
```



