```java
public class ZKRawClientDemo {
    public static void main(String[] args) throws IOException, KeeperException, InterruptedException {
        ZooKeeper zooKeeper = new ZooKeeper("127.0.0.1:2181", 30 * 1000, new Watcher() {
            @Override
            public void process(WatchedEvent watchedEvent) {
                System.out.println(watchedEvent);
            }
        });

        byte[] data = zooKeeper.getData("/liang", false, new Stat());
        System.out.println(new String(data));
    }
}
```

![image-20210202113310676](https://tva1.sinaimg.cn/large/008eGmZEly1gn918ko08jj30ke0l6q8o.jpg)

SessionId和SessionPasswd

```
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooKeeper;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Created with IntelliJ IDEA.
 * @Description: TODO(Java API -> 创建连接 -> 创建一个最基本的ZooKeeper对象实例，复用sessionId和)
 * User: zhubo
 * Date: 2018-01-09
 * Time: 21:17
 */
public class ZooKeeper_Constructor_Usage_With_SID_PASSWD implements Watcher{

    /** 定义原子变量 */
    AtomicInteger seq = new AtomicInteger();

    private static CountDownLatch countDownLatch = new CountDownLatch(1);

    public static void main(String[] args) throws Exception {
        ZooKeeper zookeeper = new ZooKeeper("192.168.20.244:2181",5000,new ZooKeeper_Constructor_Usage_With_SID_PASSWD());
        countDownLatch.await();
        long sessionId = zookeeper.getSessionId();
        byte[] passwd  = zookeeper.getSessionPasswd();
        Thread.sleep(1000L);
        //Use illegal sessionId and sessionPassWd
        zookeeper = new ZooKeeper("192.168.20.244:2181", 5000,new ZooKeeper_Constructor_Usage_With_SID_PASSWD(),1L,"test".getBytes());
        Thread.sleep(1000L);
        //Use correct sessionId and sessionPassWd
        zookeeper = new ZooKeeper("192.168.20.244:2181", 5000, new ZooKeeper_Constructor_Usage_With_SID_PASSWD(),sessionId,passwd);
        Thread.sleep( Integer.MAX_VALUE );


    }

    @Override
    public void process(WatchedEvent event) {
        System.out.println("进入 process 。。。。。event = " + event);
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if (event == null) {
            return;
        }
        // 连接状态
        Event.KeeperState keeperState = event.getState();
        // 事件类型
        Event.EventType eventType = event.getType();
        // 受影响的path
        String path = event.getPath();

        String logPrefix = "【Watcher-" + this.seq.incrementAndGet() + "】";

        System.out.println(logPrefix + "收到Watcher通知");
        System.out.println(logPrefix + "连接状态:\t" + keeperState.toString());
        System.out.println(logPrefix + "事件类型:\t" + eventType.toString());

        if (Event.KeeperState.SyncConnected == keeperState) {
            // 成功连接上ZK服务器
            if (Event.EventType.None == eventType) {
                System.out.println(logPrefix + "成功连接上ZK服务器");
                countDownLatch.countDown();
            }
            //创建节点
            else if (Event.EventType.NodeCreated == eventType) {
                System.out.println(logPrefix + "节点创建");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //this.exists(path, true);
            }
            //更新节点
            else if (Event.EventType.NodeDataChanged == eventType) {
                System.out.println(logPrefix + "节点数据更新");
                System.out.println("我看看走不走这里........");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //System.out.println(logPrefix + "数据内容: " + this.readData(PARENT_PATH, true));
            }
            //更新子节点
            else if (Event.EventType.NodeChildrenChanged == eventType) {
                System.out.println(logPrefix + "子节点变更");
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //System.out.println(logPrefix + "子节点列表：" + this.getChildren(PARENT_PATH, true));
            }
            //删除节点
            else if (Event.EventType.NodeDeleted == eventType) {
                System.out.println(logPrefix + "节点 " + path + " 被删除");
            }
            else{}
        }
        else if (Event.KeeperState.Disconnected == keeperState) {
            System.out.println(logPrefix + "与ZK服务器断开连接");
        }
        else if (Event.KeeperState.AuthFailed == keeperState) {
            System.out.println(logPrefix + "权限检查失败");
        }
        else if (Event.KeeperState.Expired == keeperState) {
            System.out.println(logPrefix + "会话失效");
        }
        else {}
        System.out.println("--------------------------------------------");
    }
}
```

注意：

客户端传入sessionId和sessionPasswd的目的是为了复用会话，以维持之前会话的有效性。

第一次使用了错误的sessionId和sessionPasswd来创建Zookeeper客户端实例，结果客户端接收到服务端的Expired事件通知；而第二次使用了正确的sessionId和sessionPasswd来创建客户端实例，结果链接成功。

> 当复用会话ID的zookeeper实例创建后，之前zookeeper链接被断开，由于zkClient的重连机制，第一个zk与第三个zk交替获取session，交替丢弃session的打印输出。



https://my.oschina.net/LucasZhu/blog/1605029

https://segmentfault.com/a/1190000021032892

https://segmentfault.com/a/1190000022306948