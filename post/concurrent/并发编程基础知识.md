# 并发编程基础知识

同步和异步：同步指的是A任务（代码）执行完成之后才能执行B任务（代码），一种顺序性执行。异步指的是无需等到A执行完成才去执行B，**Java中一般采用多线程的方式完成异步**

并行和并发：并行需要借助多核，同一时刻多个进程在运行。并发只的是一段时间内多个线程在运行

## 创建多线程方式

1. 直接使用Thread

```java
package com.zstu.concurrent.demo;

import lombok.extern.slf4j.Slf4j;

@Slf4j(topic = "c.demo01")
public class Demo01 {
    public static void main(String[] args) {
        //创建线程对象，t1是线程的名字
        Thread t = new Thread("t1"){
            //run 方法是要执行的任务
            @Override
            public void run() {
                log.info("{} running", Thread.currentThread().getName());
            }
        };
        //启动线程
        t.start();

        log.info("{} running", Thread.currentThread().getName());
    }
}
```

执行结果

```
13:33:14 [main] c.demo01 - main running
13:33:14 [t1] c.demo01 - t1 running
```

2. Runnable配合Thread

把线程和任务分开，推荐使用这种方式

```java
@Slf4j(topic = "c.demo02")
public class Demo02 {
    public static void main(String[] args) {
        Runnable r = new Runnable() {
            @Override
            public void run() {
                log.info("{} running", Thread.currentThread().getName());
            }
        };
        Thread t = new Thread(r, "t1");
        t.start();
        log.info("{} running", Thread.currentThread().getName());
    }
}
```

jdk8之后可以使用lambda表达式的方式创建线程

```java
@Slf4j(topic = "c.demo02")
public class Demo02 {
    public static void main(String[] args) {
        Runnable r = ()->log.info("{} running", Thread.currentThread().getName());
        Thread t = new Thread(r, "t1");
        t.start();
        log.info("{} running", Thread.currentThread().getName());
    }
}
```

3. FutureTask配合Thread使用

FutureTask的特点就是可以拿到子线程运行的结果

```java
@Slf4j(topic = "c.demo03")
public class Demo03 {
    public static void main(String[] args) throws Exception{
        //泛型是代表要返回的结果类型
        //FutureTask构造方法里也可以放Runnable类型，但是Runnable接口是没有返回值
        FutureTask<Integer> task = new FutureTask<>(new Callable<Integer>(){
            @Override
            public Integer call() throws Exception {
                log.info("{} running", Thread.currentThread().getName());
                return 10;
            }
        });

        new Thread(task, "t").start();
        //注意，如果线程t没有执行完成是没有返回结果，该方法会阻塞主线程
        Integer result = task.get();
        log.info("结果是：{}", result);
    }
}
```

运行结果：

```
13:43:44 [t] c.demo03 - t running
13:43:44 [main] c.demo03 - 结果是：10
```



