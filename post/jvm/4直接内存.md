# 直接内存

Java虚拟机本质是用户进程，所以在内存中开辟的空间都是在用户空间。不管是堆内存、栈内存还是**直接内存，所在的区域都是在用户空间**。内核空间是操作系统使用，用户进程不得直接访问和修改，需要拷贝到用户空间才能对数据处理。

![image-20210225152011788](https://tva1.sinaimg.cn/large/008eGmZEly1gnzt1ve247j30y50fydha.jpg)

当我们的程序不涉及系统调用的时候，我们的数据处理都是在java进程管理的内存中进行的。一旦发生系统调用，比如我们从磁盘上读取数据，首先数据从磁盘流入内核空间，接着从内核空间流到java进程的堆外空间，最后才从堆外空间拷贝到堆空间供程序使用。

![image-20210225153918420](https://tva1.sinaimg.cn/large/008eGmZEly1gnztlrrwkqj30k409gwev.jpg)

为什么会有从堆外内存拷贝到堆内存的操作呢？我们看知乎大神怎么解释的，[链接](https://www.zhihu.com/question/60892134/answer/191267896)。**也就是说不管用直接内存还是传统IO的方式读写，都会有一次从内核空间到用户空间的拷贝。**

![image-20210225154113111](https://tva1.sinaimg.cn/large/008eGmZEly1gnztnr45h4j30ig078juc.jpg)

##直接内存-allocateDirect

我们通常用`ByteBuffer.allocateDirect()`的方式分配直接内存，使用直接内存的好处就是减少了堆内存到堆外内存的拷贝，从而提高了IO读写效率。 

我们通过下面的例子来比较传统IO和直接内存的读写效率：

```java
package com.zstu.example.demo01;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

public class DirectMemoryDemo {

    public static void main(String[] args) {
        io();
        directMemory();
    }

    public static void directMemory(){
        long currentTimeMillis = System.currentTimeMillis();
        FileInputStream fileInputStream = null;
        FileOutputStream fileOutputStream = null;
        try{
            fileInputStream = new FileInputStream("/Users/Liang/Documents/001.mp4");
            fileOutputStream = new FileOutputStream("/Users/Liang/Documents/003.mp4");
            FileChannel inputChannel = fileInputStream.getChannel();
            FileChannel outputChannel = fileOutputStream.getChannel();
            ByteBuffer buffer = ByteBuffer.allocateDirect(1024*1024);
            int i = 0;
            while ((i = inputChannel.read(buffer)) != -1){
                buffer.flip();
                outputChannel.write(buffer);
                buffer.clear();
            }
        } catch (Exception ex){
            ex.printStackTrace();
        }
        System.out.println("直接内存共花费时间：" + (System.currentTimeMillis()-currentTimeMillis) + "毫秒");
    }

    public static void io(){
        long currentTimeMillis = System.currentTimeMillis();
        FileInputStream fileInputStream = null;
        FileOutputStream fileOutputStream = null;
        try{
            // 记住，这个时刻数据不加载到内存
            fileInputStream = new FileInputStream("/Users/Liang/Documents/001.mp4");
            fileOutputStream = new FileOutputStream("/Users/Liang/Documents/002.mp4");
            byte[] buffer = new byte[1024*1024];
            int i = 0;
            //read的时候读取磁盘数据到内存
            // 使用buffer可以减少IO读取
            while((i = fileInputStream.read(buffer)) != -1){
                fileOutputStream.write(buffer, 0, i);
            }
            fileInputStream.close();
            fileOutputStream.close();
        } catch (Exception ex){
            ex.printStackTrace();
        }
        System.out.println("传统io共花费时间：" + (System.currentTimeMillis()-currentTimeMillis) + "毫秒");
    }
}
```

输出：

```
传统io共花费时间：1794毫秒
直接内存共花费时间：1308毫秒
```

## 直接内存分配和回收

如果分配的直接内存过多，也是会导致内存溢出

```java
while(true){
    ByteBuffer buffer = ByteBuffer.allocateDirect(_100Mb);
    list.add(buffer);
}
```

我们可以点进`allocateDirect`源码中查看，里面使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用freeMemory方法。

ByteBuffer的实现类内部，使用了Cleaner（虚引用）来监测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放内存。<u>也就是说虽然直接内存是不由虚拟机管控，但是虚拟机内存里存放了ByteBuffer对象的地址，当启用垃圾回收的时候，通过回调的方式去调用freeMemory去释放直接内存。</u>

## allocate和allocateDirect的区别

我们的程序在跟硬件打交道的时候，都必须要内核介入，比如读取磁盘数据，网络发送信息等。数据的流动首先在用户空间，然后copy到内核空间，最后流转到对应的硬件设备上。数据从用户空间到内核空间的互相copy是来自于系统调用（system call），例如read，write等。

allocate底层调用的是HeapByteBuffer，就是在堆内分配了一个字节数组byte[] hb

allocateDirect底层调用的是DirectByteBuffer，里面调用了本地native方法unsafe.allocateMemory(size)，分配的内存放在堆外内存上。DirectByteBuffer内部用一个address变量指向了该堆外内存。

DirectByteBuffer 自身是（Java）堆内的，它背后真正承载数据的buffer是在（Java）堆外——native memory中的。这是 malloc() 分配出来的内存，是**用户态**的。

传统的BIO模式下向磁盘写数据

![image-20201023214800210](https://tva1.sinaimg.cn/large/0081Kckwly1gjzlsxqdtnj30cr08ejri.jpg)

使用NIO模式的直接内存向磁盘写数据可以省略堆内内存向堆外内存的数据copy，数据直接写到堆外内存。

补充： 

> 狭义的堆外内存
>
> 而作为java开发者，我们常说的堆外内存溢出了，其实是狭义的堆外内存，这个主要是指
>
> java.nio.DirectByteBuffer在创建的时候分配内存，我们这篇文章里也主要是讲狭义的堆外内存，因为它和我
>
> 们平时碰到的问题比较密切
>
> JDK/JVM里DirectByteBuffer的实现 
>
> DirectByteBuffer通常用在通信过程中做缓冲池，在mina，netty等nio框架中屡见不鲜
>
> 通过上面的代码我们知道可以通过-XX:MaxDirectMemorySize来指定最大的堆外内存
>
> DirectByteBuffer在创建的时候会通过Unsafe的native方法来直接使用malloc分配一块内存，这块内存是
>
> heap 之外的，那么自然也不会对gc造成什么影响(System.gc除外)，因为gc耗时的操作主要是操作heap之内
>
> 的对象，对这块内存的操作也是直接通过 Unsafe的native方法来操作的，相当于DirectByteBuffer仅仅是一
>
> 个壳，还有我们通信过程中如果数据是在Heap里的，最终也还是会copy一份到堆外，然后再进行发送，所以
>
> 为什么不直接使用堆外内存呢。对于需要频繁操作的内存，并且仅仅是临时存在一会的，都建议使用堆外内
>
> 存，并且做成缓冲池，不断循环利用这块内存。
>
> 如果我们大面积使用堆外内存并且没有限制，那迟早会导致内存溢出，毕竟程序是跑在一台资源受限的机器上，因为这块内存的回收不是你直接能控制的。
>
> 正常情况下，JVM创建一个缓冲区的时候，实际上做了如下几件事：
>
> 1. JVM确保Heap区域内的空间足够，如果不够则使用触发GC在内的方法获得空间;
> 2. 获得空间之后会找一组堆内的连续地址分配数组, 这里需要注意的是，在物理内存上，这些字节是不一定连续的;
>
> 对于不涉及到IO的操作，这样的处理没有任何问题，但是当进行IO操作的时候就会出现一点性能问题.
>
> 所有的IO操作都需要操作系统进入内核态才行，而JVM进程属于用户态进程, 当JVM需要把一个缓冲区写到某个Channel或Socket的时候，需要切换到内核态.
>
> 而内核态由于并不知道JVM里面这个缓冲区存储在物理内存的什么地址，并且这些物理地址并不一定是连续的(或者说不一定是IO操作需要的块结构)，所以在切换之前JVM需要把缓冲区复制到物理内存一块连续的内存上, 然后由内核去读取这块物理内存，整合成连续的、分块的内存.
>
> 为了解决这个问题, Java的某些版本会把物理区域分配好的部分内存做缓存就不用每次都开辟一块空间，但效果还不够好，毕竟复制的部分是少不了的.
>
> JDK1.4之后引入了NIO, 提供了一种内存映射技术, 让我们可以直接从Java代码中创建DirectBuffer，这种Buffer在创建的时候直接就在物理内存中分配一块连续内存，当需要使用的时候不再需要复制，内核直接调用即可. 但缺点也是显而易见的，就是每次分配都比较昂贵一点，同时由于分配的内存不在Java Heap中，所以也不会受用户设置的堆大小的限制.
>
> 通常情况下，大量使用IO操作的时候使用内存映射是非常值得的

## 参考

* [Java NIO direct buffer的优势在哪儿？](https://www.zhihu.com/question/60892134/answer/191267896)

* [关于JVM堆外内存的一切](https://juejin.im/post/6844903710766661639)